<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quest 3 Posture Monitor AR</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #enter-ar { position: absolute; top: 20px; left: 20px; z-index: 100; }
        #status { position: absolute; bottom: 20px; left: 20px; color: white; font-family: Arial, sans-serif; z-index: 100; }
    </style>
</head>
<body>
    <button id="enter-ar">Enter AR</button>
    <div id="status"></div>
    <script type="module">
        import * as THREE from 'https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.module.js';

        let camera, scene, renderer;
        let referencePosition, referenceOrientation;
        let arButton, statusElement;
        let overlayMesh;

        init();

        function init() {
            const container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            arButton = document.getElementById('enter-ar');
            arButton.addEventListener('click', onEnterAR);

            statusElement = document.getElementById('status');

            window.addEventListener('resize', onWindowResize, false);
        }

        function onEnterAR() {
            navigator.xr.isSessionSupported('immersive-ar').then((supported) => {
                if (supported) {
                    navigator.xr.requestSession('immersive-ar', {
                        optionalFeatures: ['dom-overlay'],
                        domOverlay: { root: document.body }
                    }).then(onSessionStarted);
                } else {
                    statusElement.textContent = 'AR not supported';
                }
            });
        }

        function onSessionStarted(session) {
            renderer.xr.setReferenceSpaceType('local');
            renderer.xr.setSession(session);

            arButton.style.display = 'none';
            statusElement.textContent = 'Calibrating... Please sit straight and look forward';

            createOverlay();

            session.addEventListener('end', onSessionEnded);

            renderer.setAnimationLoop(render);

            // Calibrate after 5 seconds
            setTimeout(calibratePosture, 5000);
        }

        function onSessionEnded() {
            arButton.style.display = 'block';
            statusElement.textContent = '';
            renderer.setAnimationLoop(null);
        }

        function createOverlay() {
            const geometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.0,
                side: THREE.DoubleSide
            });
            overlayMesh = new THREE.Mesh(geometry, material);
            overlayMesh.position.z = -0.5;
            camera.add(overlayMesh);
            scene.add(camera);
        }

        function calibratePosture() {
            const session = renderer.xr.getSession();
            const viewerPose = renderer.xr.getFrame().getViewerPose(renderer.xr.getReferenceSpace());

            if (viewerPose) {
                referencePosition = viewerPose.transform.position.clone();
                referenceOrientation = viewerPose.transform.orientation.clone();
                statusElement.textContent = 'Calibration complete. Monitoring posture...';
            } else {
                statusElement.textContent = 'Calibration failed. Please try again.';
            }
        }

        function checkPosture(position, orientation) {
            if (!referencePosition || !referenceOrientation) return false;

            const positionDeviation = position.distanceTo(referencePosition);
            const currentQuat = new THREE.Quaternion().fromArray(orientation);
            const referenceQuat = new THREE.Quaternion().fromArray(referenceOrientation);
            const angleDeviation = currentQuat.angleTo(referenceQuat);

            const positionThreshold = 0.1; // meters
            const angleThreshold = THREE.MathUtils.degToRad(15); // 15 degrees

            return positionDeviation > positionThreshold || angleDeviation > angleThreshold;
        }

        function render(timestamp, frame) {
            if (frame) {
                const viewerPose = frame.getViewerPose(renderer.xr.getReferenceSpace());
                if (viewerPose) {
                    const position = viewerPose.transform.position;
                    const orientation = viewerPose.transform.orientation;

                    const badPosture = checkPosture(position, orientation);

                    if (badPosture) {
                        overlayMesh.material.opacity = THREE.MathUtils.lerp(overlayMesh.material.opacity, 0.3, 0.1);
                        statusElement.textContent = 'Bad posture detected!';
                    } else {
                        overlayMesh.material.opacity = THREE.MathUtils.lerp(overlayMesh.material.opacity, 0.0, 0.1);
                        statusElement.textContent = 'Posture OK';
                    }
                }
            }

            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>
