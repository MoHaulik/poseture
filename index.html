<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Quest 3 Posture Monitor</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #enter-vr {
            position: absolute;
            top: 20px;
            left: 20px;
            padding: 10px 20px;
            font-size: 18px;
            z-index: 1;
        }
    </style>
</head>
<body>
    <button id="enter-vr">Enter VR</button>
    <!-- Include Three.js library from a CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Main Script -->
    <script>
        let scene, camera, renderer;
        let referenceSpace;
        let referencePose = null;
        let badPosture = false;
        let overlayMesh;

        init();

        function init() {
            // Create scene
            scene = new THREE.Scene();

            // Create camera
            camera = new THREE.PerspectiveCamera(
                70,
                window.innerWidth / window.innerHeight,
                0.01,
                1000
            );

            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            document.body.appendChild(renderer.domElement);

            // Add VR button functionality
            const btn = document.getElementById('enter-vr');
            btn.addEventListener('click', () => {
                if (navigator.xr) {
                    navigator.xr.isSessionSupported('immersive-vr').then((supported) => {
                        if (supported) {
                            renderer.xr.setSessionInit({
                                optionalFeatures: [
                                    'local-floor',
                                    'bounded-floor',
                                    'hand-tracking',
                                    'layers',
                                    'dom-overlay',
                                    'camera-access',
                                    'passthrough'
                                ],
                                domOverlay: { root: document.body }
                            });
                            navigator.xr.requestSession('immersive-vr', {
                                optionalFeatures: [
                                    'local-floor',
                                    'bounded-floor',
                                    'hand-tracking',
                                    'layers',
                                    'dom-overlay',
                                    'camera-access',
                                    'passthrough'
                                ],
                                domOverlay: { root: document.body }
                            }).then(onSessionStarted);
                        } else {
                            alert('Immersive VR not supported on this device.');
                        }
                    });
                } else {
                    alert('WebXR not supported in this browser.');
                }
            });
        }

        function onSessionStarted(session) {
            renderer.xr.setSession(session);
            session.requestReferenceSpace('local').then((refSpace) => {
                referenceSpace = refSpace;
                createOverlay();
                renderer.setAnimationLoop(render);
                calibratePosture();
            });
        }

        function calibratePosture() {
            // Wait 2 seconds before calibrating to ensure the XR session is ready
            setTimeout(() => {
                const xrFrame = renderer.xr.getFrame();
                const viewerPose = xrFrame.getViewerPose(referenceSpace);
                if (viewerPose) {
                    const transform = viewerPose.transform;
                    referencePose = {
                        position: {
                            x: transform.position.x,
                            y: transform.position.y,
                            z: transform.position.z
                        },
                        orientation: {
                            x: transform.orientation.x,
                            y: transform.orientation.y,
                            z: transform.orientation.z,
                            w: transform.orientation.w
                        }
                    };
                    alert('Calibration complete. Maintaining this posture will prevent alerts.');
                } else {
                    alert('Unable to calibrate posture. Please try again.');
                }
            }, 2000);
        }

        function render(timestamp, xrFrame) {
            if (!referencePose) {
                renderer.render(scene, camera);
                return;
            }

            const session = renderer.xr.getSession();
            const viewerPose = xrFrame.getViewerPose(referenceSpace);

            if (viewerPose) {
                const transform = viewerPose.transform;
                const position = transform.position;
                const orientation = transform.orientation;

                // Calculate deviations
                const positionDeviation = calculatePositionDeviation(position, referencePose.position);
                const orientationDeviation = calculateOrientationDeviation(orientation, referencePose.orientation);

                // Determine if posture is bad
                badPosture = isBadPosture(positionDeviation, orientationDeviation);

                // Update overlay visibility based on posture
                updateOverlay();

                renderer.render(scene, camera);
            }
        }

        function createOverlay() {
            const geometry = new THREE.PlaneGeometry(2, 2);
            const material = new THREE.MeshBasicMaterial({
                color: 0xff0000,
                transparent: true,
                opacity: 0.0
            });
            overlayMesh = new THREE.Mesh(geometry, material);
            overlayMesh.position.z = -0.5; // Position it in front of the camera
            camera.add(overlayMesh);
            scene.add(camera);
        }

        function updateOverlay() {
            if (badPosture) {
                overlayMesh.material.opacity = THREE.MathUtils.lerp(overlayMesh.material.opacity, 0.3, 0.1);
            } else {
                overlayMesh.material.opacity = THREE.MathUtils.lerp(overlayMesh.material.opacity, 0.0, 0.1);
            }
        }

        function calculatePositionDeviation(currentPos, referencePos) {
            const dx = currentPos.x - referencePos.x;
            const dy = currentPos.y - referencePos.y;
            const dz = currentPos.z - referencePos.z;
            return Math.sqrt(dx * dx + dy * dy + dz * dz);
        }

        function calculateOrientationDeviation(currentOri, referenceOri) {
            const currentQuat = new THREE.Quaternion(
                currentOri.x,
                currentOri.y,
                currentOri.z,
                currentOri.w
            );

            const referenceQuat = new THREE.Quaternion(
                referenceOri.x,
                referenceOri.y,
                referenceOri.z,
                referenceOri.w
            );

            const angle = currentQuat.angleTo(referenceQuat);
            return angle;
        }

        function isBadPosture(positionDeviation, orientationDeviation) {
            const positionThreshold = 0.15; // in meters
            const orientationThreshold = THREE.MathUtils.degToRad(15); // in radians

            return positionDeviation > positionThreshold || orientationDeviation > orientationThreshold;
        }
    </script>
</body>
</html>
